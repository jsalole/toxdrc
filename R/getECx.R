#' Get ECx estimates from model
#'
#' @param dataset A dataframe.
#' @param model A drm model, generated by `modelcomp()` or `drm()`.
#' @param EDx The effect measure of interest (i.e. 0.5 for EC50)
#' @param metadata Optional. Generated by getmetadata.
#' @param list_obj Optional. Used for integration with `runtoxdrc`.
#' @param interval Character. Method for calculating confidence intervals of EDx. Choices: `"tfls"`, `"fls"`, `"delta"`, `"none"`. Default: "tfls".
#' @param level Numeric. Confidence level for the interval calculation. Default: 0.95.
#' @param type Character. Whether EDx is calculated as `"absolute"` or `"relative"`. Default: "absolute".
#' @param quiet Logical. Whether EDx results should be printed. Default: FALSE.
#' @param EDargs.supplement List. Optional user-supplied list of additional or overriding ED arguments.
#' Can include `interval`, `level`, `type`, or other arguments compatible with `drc::ED()`.
#' @returns If list_obj is not provided, returns estimate. If list object is provided, list_obj$results stores a dataframe with the ECx estimates.
#' @importFrom drc ED
#' @export

getECx <- function(
  dataset,
  model,
  EDx = 0.5,
  interval = c("tfls", "fls", "delta", "none"),
  level = 0.95,
  type = c("absolute", "relative"),
  quiet = FALSE,
  EDargs.supplement = list(),
  metadata = NULL,
  list_obj = NULL
) {
  interval <- match.arg(interval)
  type <- match.arg(type)

  # Build argument list for ED()
  EDargs <- c(
    list(
      object = model,
      respLev = EDx,
      interval = interval,
      level = level,
      type = type,
      display = !quiet
    ),
    EDargs.supplement
  )

  # Safely run ED() and capture output
  EDvals <- tryCatch(
    suppressWarnings(do.call(ED, EDargs)),
    error = function(e) return(NULL)
  )

  # Handle failed fit or NA result
  if (is.null(EDvals)) {
    n_ecx <- length(EDx)
    return(
      data.frame(
        `Effect Measure` = paste0("EC", EDx * 100),
        Estimate = rep(NA, n_ecx),
        `Std. Error` = rep(NA, n_ecx),
        Lower = rep(NA, n_ecx),
        Upper = rep(NA, n_ecx)
      )
    )
  }

  ## --- Clean and format output --- ##

  # Convert to data frame, preserving numeric types
  EDdf <- as.data.frame(EDvals, stringsAsFactors = FALSE)

  # Add ECx labels from rownames
  EDdf$`Effect Measure` <- paste0(
    "EC",
    gsub("\\.0+$", "", as.numeric(sub(".*:", "", rownames(EDdf))) * 100)
  )

  # Reorder columns (Effect Measure first)
  EDdf <- EDdf[, c(
    "Effect Measure",
    names(EDdf)[names(EDdf) != "Effect Measure"]
  )]

  # Ensure missing columns (Lower/Upper) exist if interval = "none"
  expected_cols <- c("Estimate", "Std. Error", "Lower", "Upper")
  missing_cols <- setdiff(expected_cols, names(EDdf))
  if (length(missing_cols) > 0) {
    EDdf[missing_cols] <- NA
  }

  rownames(EDdf) <- NULL

  # Print if requested
  if (!quiet) {
    print(EDdf)
  }

  ## --- Combine or return --- ##
  if (is.null(list_obj)) {
    if (!is.null(metadata)) {
      EDdf <- cbind(metadata, EDdf)
    }
    return(EDdf)
  } else {
    if (!is.list(list_obj)) {
      stop("Provided list_obj must be a list.")
    }
    if (!is.null(metadata)) {
      list_obj$results <- cbind(metadata, EDdf)
    } else {
      list_obj$results <- EDdf
    }
    return(list_obj)
  }
}
